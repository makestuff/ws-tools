## FPGA Workspace Tools
These are some tools for creating and maintaining workspaces for FPGA projects. You should clone this repo somewhere convenient, and add it to your `PATH` so that the tools are available to you. For example:

    cd $HOME
    git clone git@github.com:makestuff/ws-tools.git
    export PATH=${PATH}:${HOME}/ws-tools

The MakeStuff FPGA components and tools all assume a standard project layout, consisting of four levels of hierarchy:

* A *project* or workspace represents an actual FPGA project, capable of being built into a bitfile and loaded into an FPGA. You can identify which project you're working on from the `PROJ_HOME` environment variable, which needs to be set to the absolute path of the project root. It's your project, so it can contain whatever you like, with only two constraints: it must have a [git submodule](https://git-scm.com/book/en/v2/Git-Tools-Submodules) of [`makestuff:hdl-tools`](https://github.com/makestuff/hdl-tools) at `$PROJ_HOME/hdl-tools`, and it must incorporate one or more **libraries**, which will live under `$PROJ_HOME/ip/`.

* A *library* is an umbrella for a bunch of components hosted in the same place. For example, if you use components from http://github.com/makestuff, they will exist under `$PROJ_HOME/ip/makestuff/`. Each library (e.g "`makestuff`") has an associated clone URL (e.g "`git@github.com:makestuff`" or "`https://github.com/makestuff`"), hosted on GitHub or elsewhere (e.g a [Bitbucket Server](https://www.atlassian.com/software/bitbucket/enterprise/data-center) on your corporate network). Each library provides one or more **components**.

* A *component* consists of some RTL code and its associated unit & integration tests. The RTL code may be human-written or generated by some process invoked at build-time. It may be a reusable component (e.g a UART or a soft-core CPU), in which case it makes sense for it to be a [git submodule](https://git-scm.com/book/en/v2/Git-Tools-Submodules). Alternatively, it may be one of the integral components of your application, and not reusable, in which case it can be a regular directory. For example, if your application requires [`makestuff:pcie-hip`](https://github.com/makestuff/pcie-hip), it will be [submoduled](https://git-scm.com/book/en/v2/Git-Tools-Submodules) at `$PROJ_HOME/ip/makestuff/pcie-hip`. Components may depend on other components. There will be a Makefile at `$PROJ_HOME/ip/Makefile` which will specify the build order of all your components, such that when the time comes to build any given component, all its dependencies have already been built. A component will have zero or more **testbenches**, which will verify the functionality of the component in simulation.

* A *testbench* consists of some test code (and possibly some behavioral models) that can verify the correctness of its associated RTL code. A testbench may be a unit-test (i.e testing only this component in isolation) or an integration-test (i.e testing the interaction of this component with some other components). A testbench is identified as a subdirectory of a component, whose name has a `tb-` prefix (e.g "`tb-unit`"). It will typically instantiate one of the RTL modules of your component, drive its inputs and verify correct output. A good way to write such tests is to use the macros provided by [SVUnit](http://agilesoc.com/open-source-projects/svunit). These are included for your convenience by [`makestuff:hdl-tools`](https://github.com/makestuff/hdl-tools).

### Creating a new workspace: `mkws.sh`
This creates a top-level workspace for you, possibly incorporating a bunch of reusable components as [git submodules](https://git-scm.com/book/en/v2/Git-Tools-Submodules), maybe running their tests and generating a test-report.

    $ mkws.sh
    Synopsis: ./mkws.sh [-t] [-r] [-u meta=url ...] <ws-name> [<library:component> ...]
      -t: Run tests for the components
      -r: Generate a test report (ignored if -t not given)
      -u library=url: Specify the clone URL for a library of components

For example:

    $ mkws.sh foobar
    $ find foobar -type f
    foobar/.git/...
    foobar/README.md
    foobar/hdl-tools/...
    foobar/ip/Makefile
    $

You can also import some reusable components, specifying each of the form `library:component`:

    $ mkws.sh foobar makestuff:block-ram makestuff:dvr-rng
    $ find foobar -type f
    foobar/.git/...
    foobar/README.md
    foobar/hdl-tools/...
    foobar/ip/Makefile
    foobar/ip/makestuff/block-ram/...
    foobar/ip/makestuff/dvr-rng/...
    $

If you want to import more than one component, the shell provides you with a useful shorthand of the form `library:{component1,component2,...}`:

    $ mkws.sh foobar makestuff:{altera-libs,buffer-fifo,block-ram,dvr-rng,pcie-hip}
    $ find foobar -type f
    foobar/.git/...
    foobar/README.md
    foobar/hdl-tools/...
    foobar/ip/Makefile
    foobar/ip/makestuff/altera-libs/...
    foobar/ip/makestuff/block-ram/...
    foobar/ip/makestuff/buffer-fifo/...
    foobar/ip/makestuff/dvr-rng/...
    foobar/ip/makestuff/pcie-hip/...
    $

Note that the order is important - the `pcie-hip` component depends on the other components, so it must come last - in general, leaf-nodes in the dependency graph must come first, and the root-node must come last.

You can also run the unit-tests (`-t`) of the imported components, and generate a report (`-r`):

    $ mkws.sh -t -r foobar makestuff:{altera-libs,buffer-fifo,block-ram,dvr-rng,pcie-hip}
    :
    $ ls -la foobar/svunit.xml
    -rw-r--r-- 1 chris users 1342 Jan 24 15:40 foobar/svunit.xml
    $

Perhaps you want to incorporate your own (or someone else's) components? You'll need to tell the script how to construct the clone URLs. For example, if your GitHub account is http://github.com/fpgafoo, you could import your components `uart` and `z80-core` (having clone URLs http://github.com/fpgafoo/uart.git and http://github.com/fpgafoo/z80-core.git respectively) like this:

    $ mkws.sh -ufpgafoo=http://github.com/fpgafoo foobar fpgafoo:{uart,z80-core}
    $ find foobar -type f
    foobar/.git/...
    foobar/README.md
    foobar/hdl-tools/...
    foobar/ip/Makefile
    foobar/ip/fpgafoo/uart/...
    foobar/ip/fpgafoo/z80-core/...
    $

In natural language, such an operation can be described thus:

> "Please create me a new workspace called `foobar` and initialize it with the components `uart` and `z80-core` from the `fpgafoo` library, whose clone-URL is `http://github.com/fpgafoo`".

Be sure to verify that the code on http://github.com/fpgafoo is trustworthy before running the build, which of course can result in arbitrary code execution on your machine.

If you get bored with having to specify a bunch of `-u` options for the libraries you use, you can just add a line to [`urls.sh`](urls.sh) to make the mapping permanent:

    $ cat urls.sh 
    # Included by mkws.sh - you can add your own mappings here
    URL[makestuff]=git@github.com:makestuff
    URL[fpgafoo]=http://github.com/fpgafoo

You could for example use this mechanism to specify the clone URLs of the component libraries hosted within your corporate environment.

Similarly, you can edit [`mkrp.sh`](mkrp.sh) in order to customize the report-generation, which by default creates a `$PROJ_HOME/svunit.xml` file, which when placed alongside a suitable stylesheet (e.g [`adarmalik/gtest2html.xslt`](https://github.com/adarmalik/gtest2html/blob/master/gtest2html.xslt)), it should render nicely in  your browser.

### Creating a new component: `mkcp.sh`
Once you have a workspace, you can create a new "skeleton" component using `mkcp.sh`. This uses the same `library:component` naming convention as the `mkws.sh` script, to create a fully-functional template component that you can edit to meet your needs. All it actually produces is the RTL to instantiate a hardware multiplier of configurable width, and associated testbench: useless from a practical point-of-view, but useful as a template on which to build your own functionality.

So:

    $ mkcp.sh fpgafoo:z80-core
    Creating Makefile...
    Creating z80_core.qip...
    Creating z80_core.sv...
    Creating README.md...
    Creating tb-unit/Makefile...
    Creating tb-unit/z80_core_tb.sv...
    Creating tb-unit/sim.do...
    $

It will already be functional, so you can immediately run the tests:

    $ make -C $PROJ_HOME/ip/fpgafoo/z80-core test
    make: Entering directory '.../foobar/ip/fpgafoo/z80core'
    :
    make: Leaving directory '.../foobar/ip/fpgafoo/z80core'
    $

Notice that the component-name is `fpgafoo:z80-core`, which means it will exist at `$PROJ_HOME/ip/fpgafoo/z80-core`, but in the generated code, the hyphen is replaced with an underscore in order to make it a valid SystemVerilog identifier:

```systemverilog
$ cat $PROJ_HOME/ip/fpgafoo/z80-core/z80_core.sv
module fpgafoo_z80_core#(
    parameter int A_NBITS,
    parameter int B_NBITS
  )(
    input  logic                        clk_in,
    input  logic[A_NBITS-1 : 0]         a_in,
    input  logic[B_NBITS-1 : 0]         b_in,
    output logic[A_NBITS+B_NBITS-1 : 0] x_out
  );
  always_ff @(posedge clk_in) begin
    x_out <= a_in * b_in;
  end
endmodule
```

The testbench uses [SVUnit](http://agilesoc.com/open-source-projects/svunit) macros to do asserts, etc. Running the testbench in headless mode as shown above just runs the lines 18-21 of the `sim.do` file:

```tcl
set SEED [clock seconds]
foreach B_NBITS {2 4 8 16} {
  cli_run "-gSEED=$SEED -gA_NBITS=16 -gB_NBITS=$B_NBITS"
}
```

That will set the `SEED` parameter (which seeds the random-number generator used for choosing test values) to the number of seconds since the epoch, `A_NBITS` to the fixed value `16` and it will try running the testbench with several values of `B_NBITS`: `2`, `4`, `8` and `16`. If you don't care about that stuff, you can simplify it. The simplest valid headless-mode entry in `sim.do` is just `cli_run` on its own.

In addition to headless mode, you can also run the testbench in the ModelSim GUI:

    cd $PROJ_HOME/ip/fpgafoo/z80-core/tb-unit
    make testgui

That will produce a nice waveform output:

![ModelSim Waves](/img/waves.png)

Notice that the value of `/z80_core_tb/uut/x_out` at the cursor is `399,281,805`, which is indeed the product of the inputs `a_in` (`22305`) and `b_in` (`17901`) from the previous cycle (hardware multiply is a single-cycle sequential operation).

Notice line 16 of `sim.do`:

    gui_run 160 65 0 10 0 32 70

These numbers configure the ModelSim GUI to display things nicely:

* `160`: The pixel-width of the signal-name column (`namecolwidth`).
* `65`: The pixel-width of the value column (`valuecolwidth`).
* `0`: The clock offset in nanoseconds (`gridoffset`).
* `10`: The clock period in nanoseconds (`gridperiod`).
* `0`: The time in nanoseconds to start displaying.
* `32`: The number of clocks to display.
* `70`: The time in nanoseconds at which to position the cursor.

If you don't care about GUI mode or about running the testbench with several parameter values, you can just delete the `sim.do` file altogether, whereupon the test process will just launch the testbench using default parameter values. I encourage you to keep the `sim.do` file around though: your colleagues will find it much easier to track down a bug in your component if you provide them with a decent `sim.do` file they can use to launch your component in GUI mode.

### Generate a test report: `mkrp.sh`
This is the script called by `mkws.sh` in order to generate a test report. You can edit it to customize how your report is generated. You can also invoke it manually (e.g after having re-run some tests).

Have fun!
